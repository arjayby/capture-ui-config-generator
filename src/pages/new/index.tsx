import { useState } from "react";
import Link from "next/link";
import Head from "next/head";
import dynamic from "next/dynamic";
import { Active, DndContext, DragEndEvent, DragOverEvent, DragStartEvent } from "@dnd-kit/core";
import { arrayMove } from "@dnd-kit/sortable";
import { Checkbox, Container, Icon } from "semantic-ui-react";
import SortableListView from "@/components/SortableListView";
import SortableListSection from "@/components/SortableListSection";
import { useAppStore, useFormStore } from "@/store";

export default function New() {
  return (
    <>
      <Head>
        <title>Capture UI Config Generator</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Container>
        <DynamicForm />
      </Container>
    </>
  );
}

function Form() {
  const [active, setActive] = useState<Active | null>(null);

  const preview = useAppStore((state) => state.preview);
  const invertPreview = useAppStore((state) => state.invertPreview);

  const activeViewId = useFormStore((state) => state.activeViewId);
  const viewsOrder = useFormStore((state) => state.viewsOrder);
  const views = useFormStore((state) => state.views);
  const sections = useFormStore((state) => state.sections);
  const fieldsets = useFormStore((state) => state.fieldsets);
  const grids = useFormStore((state) => state.grids);

  const setViewsOrder = useFormStore((state) => state.setViewsOrder);
  const updateView = useFormStore((state) => state.updateView);
  const updateSection = useFormStore((state) => state.updateSection);
  const updateFieldset = useFormStore((state) => state.updateFieldset);
  const updateGrid = useFormStore((state) => state.updateGrid);

  const activeView = views[activeViewId];

  const handleDragStart = ({ active }: DragStartEvent) => {
    setActive(active);
  };

  const handleDragOver = ({ active, over }: DragOverEvent) => {
    if (!over) return;

    const activePrefix = active.id.toString().split("-")[0];
    const overPrefix = over.id.toString().split("-")[0];

    const activeParent = active.data.current?.parent;

    if (
      activePrefix === "field" &&
      overPrefix === "grid" &&
      !grids[over.id].fields.includes(active.id.toString())
    ) {
      const activeSection = {
        ...grids[activeParent],
        fields: grids[activeParent].fields.filter((field) => field !== active.id.toString()),
      };
      const overSection = {
        ...grids[over.id],
        fields: [...grids[over.id].fields, active.id.toString()],
      };

      updateGrid(activeParent, activeSection);
      updateGrid(over.id.toString(), overSection);
    }
  };

  const handleDragEnd = ({ active, over }: DragEndEvent) => {
    if (!over) return;
    if (active.id === over?.id) return;

    const activeParent = active.data.current?.parent;
    const overParent = over.data.current?.parent;

    if (activeParent === overParent) {
      const activeId = active.id.toString();
      const overId = over.id.toString();
      const activePrefix = activeId.split("-")[0];

      if (activePrefix === "view") {
        const activeIndex = viewsOrder.indexOf(activeId);
        const overIndex = viewsOrder.indexOf(overId);

        const newViewsOrder = arrayMove(viewsOrder, activeIndex, overIndex);

        setViewsOrder(newViewsOrder);
      }

      if (activePrefix === "section") {
        const activeIndex = views[activeParent].sections.indexOf(activeId);
        const overIndex = views[overParent].sections.indexOf(overId);

        const newView = {
          ...views[activeParent],
          sections: arrayMove(views[activeParent].sections, activeIndex, overIndex),
        };

        updateView(activeParent, newView);
      }

      if (activePrefix === "fieldset") {
        const activeIndex = sections[activeParent].fieldsets.indexOf(activeId);
        const overIndex = sections[overParent].fieldsets.indexOf(overId);

        const newSection = {
          ...sections[overParent],
          fieldsets: arrayMove(sections[overParent].fieldsets, activeIndex, overIndex),
        };

        updateSection(overParent, newSection);
      }

      if (activePrefix === "grid") {
        const activeIndex = fieldsets[activeParent].grids.indexOf(activeId);
        const overIndex = fieldsets[overParent].grids.indexOf(overId);

        const newFieldset = {
          ...fieldsets[overParent],
          grids: arrayMove(fieldsets[overParent].grids, activeIndex, overIndex),
        };

        updateFieldset(overParent, newFieldset);
      }

      if (activePrefix === "field") {
        const activeIndex = grids[activeParent].fields.indexOf(activeId);
        const overIndex = grids[overParent].fields.indexOf(overId);

        const newGrid = {
          ...grids[overParent],
          fields: arrayMove(grids[overParent].fields, activeIndex, overIndex),
        };

        updateGrid(overParent, newGrid);
      }
    }

    setActive(null);
  };

  const handleDragCancel = () => {
    setActive(null);
  };

  return (
    <DndContext
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
      onDragCancel={handleDragCancel}
    >
      <Container style={{ padding: "2rem 0" }}>
        <div style={{ display: "flex", justifyContent: "space-between", marginBottom: "2rem" }}>
          <Link href="/">
            <Icon size="large" name="arrow left" color="black" />
          </Link>
          <div style={{ display: "flex", gap: "2rem" }}>
            <Checkbox toggle label="Preview" onChange={invertPreview} checked={preview} />
          </div>
        </div>
        <SortableListView active={active} views={viewsOrder.map((view) => views[view])} />
        <SortableListSection
          active={active}
          parent={activeView.id}
          sections={activeView.sections.map((section) => sections[section])}
        />
      </Container>
    </DndContext>
  );
}

const DynamicForm = dynamic(() => Promise.resolve(Form), {
  ssr: false,
});
